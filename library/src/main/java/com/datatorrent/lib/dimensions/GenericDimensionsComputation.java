/*
 * Copyright (c) 2015 DataTorrent, Inc. ALL Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.datatorrent.lib.dimensions;

import com.datatorrent.api.Context.OperatorContext;
import com.datatorrent.api.DefaultInputPort;
import com.datatorrent.api.DefaultOutputPort;
import com.datatorrent.api.Operator;
import com.datatorrent.lib.appdata.schemas.DimensionalConfigurationSchema;
import com.datatorrent.lib.appdata.schemas.FieldsDescriptor;
import com.datatorrent.lib.dimensions.DimensionsEvent.Aggregate;
import com.datatorrent.lib.dimensions.DimensionsEvent.EventKey;
import com.datatorrent.lib.dimensions.DimensionsEvent.InputEvent;
import com.datatorrent.lib.dimensions.aggregator.AggregatorRegistry;
import com.datatorrent.lib.dimensions.aggregator.IncrementalAggregator;
import com.datatorrent.lib.statistics.DimensionsComputation;
import com.google.common.collect.Lists;
import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
import it.unimi.dsi.fastutil.ints.IntArrayList;
import javax.validation.constraints.NotNull;

import java.util.Collections;
import java.util.List;
import java.util.Map;

public abstract class GenericDimensionsComputation<EVENT> implements Operator
{
  /**
   * The default schema ID.
   */
  public static final int DEFAULT_SCHEMA_ID = 1;

  /**
   * This holds the JSON which defines the {@link DimensionalConfigurationSchema} to be used by this operator.
   */
  @NotNull
  private String configurationSchemaJSON;
  /**
   * The {@link DimensionalConfigurationSchema} to be used by this operator.
   */
  protected DimensionalConfigurationSchema configurationSchema;
  /**
   * The schemaID applied to {@link DimensionsEvent}s generated by this operator.
   */
  private int schemaID = DEFAULT_SCHEMA_ID;

  private DimensionsComputation<InputEvent, Aggregate> dimensionsComputation;

  /**
   * The {@link AggregatorRegistry} to use for this dimensions computation operator.
   */
  private AggregatorRegistry aggregatorRegistry = AggregatorRegistry.DEFAULT_AGGREGATOR_REGISTRY;

  private DimensionsComputationUnifierImpl<Object, DimensionsEvent> unifier;

  private InputEvent inputEvent;

  /**
   * The output port for the aggregates.
   */
  public final transient DefaultOutputPort<DimensionsEvent> output = new DefaultOutputPort<DimensionsEvent>() {
    @Override
    public Unifier<DimensionsEvent> getUnifier()
    {
      return unifier;
    }
  };

  /**
   * The input port which receives events to perform dimensions computation on.
   */
  public transient final DefaultInputPort<EVENT> input = new DefaultInputPort<EVENT>() {
    @Override
    public void process(EVENT tuple)
    {
      processInputEvent(tuple);
    }
  };

  public GenericDimensionsComputation()
  {
  }

  @Override
  @SuppressWarnings({"unchecked","rawtypes"})
  public void setup(OperatorContext context)
  {
    InputEvent inputEvent = ;

    //Num incremental aggregators
    int numIncrementalAggregators = 0;

    for(int dimensionsDescriptorID = 0;
        dimensionsDescriptorID < configurationSchema.getDimensionsDescriptorIDToAggregatorIDs().size();
        dimensionsDescriptorID++) {
      IntArrayList aggIDList = configurationSchema.getDimensionsDescriptorIDToAggregatorIDs().get(dimensionsDescriptorID);
      numIncrementalAggregators += aggIDList.size();
    }

    IncrementalAggregator[] aggregatorArray = new IncrementalAggregator[numIncrementalAggregators];

    for(int ddID = 0;
        ddID < keyFieldsDescriptors.size();
        ddID++) {
      //Create the conversion context for the conversion.
      FieldsDescriptor keyFieldsDescriptor = keyFieldsDescriptors.get(ddID);
      Int2ObjectMap<FieldsDescriptor> map = configurationSchema.getDimensionsDescriptorIDToAggregatorIDToInputAggregatorDescriptor().get(ddID);
      IntArrayList aggIDList = configurationSchema.getDimensionsDescriptorIDToAggregatorIDs().get(ddID);
      DimensionsDescriptor dd = configurationSchema.getDimensionsDescriptorIDToDimensionsDescriptor().get(ddID);

      for(int aggIDIndex = 0;
          aggIDIndex < aggIDList.size();
          aggIDIndex++) {
        int aggID = aggIDList.get(aggIDIndex);

        conversionContext.schemaID = schemaID;
        conversionContext.dimensionDescriptorID = ddID;
        conversionContext.aggregatorID = aggID;
        conversionContext.dimensionDescriptorID = ddID;

        conversionContext.dd = dd;
        conversionContext.keyFieldsDescriptor = keyFieldsDescriptor;
        conversionContext.aggregateDescriptor = map.get(aggID);

        InputEvent inputE = convertInput(input,
                                         conversionContext);

        int aggregateIndex = this.aggregatorIdToAggregateIndex.get(conversionContext.aggregatorID);
        processConvertedInput(aggregateIndex,
                              inputE);
      }
    }

    dimensionsComputation = new DimensionsComputation<InputEvent, Aggregate>();

    Map<Integer, IncrementalAggregator<Object>> idToAggregator = aggregatorRegistry.getIncrementalAggregatorIDToAggregator();

    List<Integer> ids = Lists.newArrayList(idToAggregator.keySet());
    aggregatorIdToAggregateIndex = new Int2IntOpenHashMap();
    Collections.sort(ids);

    IncrementalAggregator[] aggregatorArray = new IncrementalAggregator[ids.size()];

    for(int aggregateIndex = 0;
        aggregateIndex < ids.size();
        aggregateIndex++) {
      int aggregatorId = ids.get(aggregateIndex);
      aggregatorIdToAggregateIndex.put(aggregatorId, aggregateIndex);
      aggregatorArray[aggregateIndex] = idToAggregator.get(aggregatorId);
    }

    unifier = new DimensionsComputationUnifierImpl<InputEvent, Aggregate>();
    unifier.setAggregators(aggregatorArray);
  }

  @Override
  public void beginWindow(long windowId)
  {
    dimensionsComputation.beginWindow(windowId);
  }

  @Override
  public void endWindow()
  {
    dimensionsComputation.endWindow();
  }

  @Override
  public void teardown()
  {
    dimensionsComputation.teardown();
  }

  public abstract void processInputEvent(EVENT inputEvent);

  /**
   * @return the aggregatorRegistry
   */
  public AggregatorRegistry getAggregatorRegistry()
  {
    return aggregatorRegistry;
  }

  /**
   * @param aggregatorRegistry the aggregatorRegistry to set
   */
  public void setAggregatorRegistry(AggregatorRegistry aggregatorRegistry)
  {
    this.aggregatorRegistry = aggregatorRegistry;
  }

  public static class DimensionsConversionContext
  {
    /**
     * The {@link DimensionsDescriptor} corresponding to the given dimension descriptor id.
     */
    public DimensionsDescriptor dd;
    /**
     * The {@link FieldsDescriptor} for the aggregate of a new {@link InputEvent}.
     */
    public FieldsDescriptor aggregateDescriptor;
    /**
     * The event key corresponding to this dimensions descriptor
     */
    public EventKey eventKey;
    public int timestampIndex;

    /**
     * Constructor for creating conversion context.
     */
    public DimensionsConversionContext()
    {
      //Do nothing.
    }
  }
}
